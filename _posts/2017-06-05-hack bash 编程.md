---
layout: post
title: Hack Bash 编程 学习笔记
tags:
- Bash
- Linux
- 编程
categories: 学习
---
又一个从入门到放弃的学习笔记。

又找到一本书，叫做《Bash中文文档》，体会到了读文档的重要性。这段时间一直都在看跟技术编程有关的书籍，因为希望以后的工作能够更加的顺畅，更多的受益于这些自动化的手段，让自己从简单的重复劳动中解脱出来。






* content
{:toc}
### 第一章 总体介绍
1，什么是bash

bash就是一个操作操作系统的shell，命令解释器，现在在linux和mac中广泛应用。

2，什么是shell

shell就是一个能执行各种命令的宏处理器。

### 第二章 术语定义

基本上就是，各种定义，比如posix，空白符，控制运算符等的定义。

### 第三章 shell的基本功能

#### shell的语法

shell在读取输入的时候，要经过一系列的操作，如果在输入中开始了一个注释，shell会把注释符号#以及后面的一整行都忽略掉。概括的说，shell会读取输入并将之分解为一个个单词和运算符，并使用引用规则来决定每个单词和字符的不同的含义。然后shell会把这些解析为命令和其他结构去除一些特定单词的特殊含义，对另外一些进行扩展，根据需要进行重定向，执行指定的命令，等待其退出状态，并让这个状态能用于后续的检查和处理。

1. 引用，引用在shell中用来除去某些特殊的字符或者单词，它可以用来禁止对特殊字符的特殊处理，使得保留字不再被认为是保留字，或者禁止参数扩展。bash有三种引用机制
- 转义字符
- 单引用
- 双引用
2. 转义字符,在bash中，没有转义的反斜杠 \ 是转义字符，他能保留其下一个字符的的字面含义，除非这个字符是换行符。如果出现 \ 符号后后面直接跟着新的一行，也就是说，这个符号是一行的最后一个字符，后面没有紧接着的字符，而这个反斜杠也没有被别的引用，那么就表示，这个符号的前面的行和这个符号后面的那行其实是在一行的，连续的。在流输入的时候，这里换行这件事情，会被忽略掉。
3. 单引用,把字符用单引号引用，能够保留银行内部各个字符的字面含义。但是，在这对单引号内部就不能够再使用别的单引号了，就算已经被转义（被反斜杠转义）过的单引号也不行。
4. 双引用,把字符串用双引号 “ 引用，能够保留引号内部的各个字符的字面含义，这点和单引用类似。
- 但是像$ ‘ \\ ! 这四个符号不行，他们不能保留字面含义。在双引号中，$和’继续保留它的特殊的功能；
- 反斜杠只有在后面的字符是$ ‘ \\ ! 或者换行符的时候，才保留它的特殊的含义，在双引号中，如果反斜杠后面是这些字符中的任意一个，那么这个反斜杠就会被删除。
- 而反斜杠后面的字符如果没有特殊的含义，那么它将被保留。
- 在双引号中，可以出现另一个双引号，只要它在反斜杠后面（也就是说被转义了）。
- 如果打开了历史扩展，！将导致历史扩展，除非它被反斜杠转义，在！前面的反斜杠不会被删除。

> 在很多命令中，都需要指定单个字符，这时候应该使用ansi标准c引用，双引号转义就不行。比如：
> 
> tr $’\n’ ‘ ‘ file
> 
> 把一个叫做file的文件里面所有的行，用空格连接起来。

- 这里面的\n,表示新的一行，前面加上$,表示使用这个变量，加上‘’表示对这个变量进行引用。
- 类似的符号还有这么多：

> \a	警告-响铃
> > \b	退格删除
> > \e	转义字符-不属于ansi c
> > \f	走纸换页
> > \n	新行
> > \r	换行
> > \t	水平-制表符
> > \v	垂直-制表符
> 
> \’	单引号
> 
> \\	反斜杠
> > \nn	由八进制数nnn代表的一个八位字符
> > \xHH	由16进制数HH代表的一个八位字符
> > \cx	一个控制字符 CTROL_X

#### shell的命令

一个简单的shell 命令例如通过 echo a b c,包含该命令本身，其后还有一些参数，他们都用空格隔开。

复杂一些的命令由简单的命令通过各种方式组合而成，通过管道命令，这时一个命令的输出成为另一个命令的输入，或者通过循环或条件的命令，或者通过其他的组合方式。

1. 简单的命令使用最频繁，他仅仅包括空白分隔的多个单词，其结尾是一个shell控制运算符，其中第一个单词通过指定要执行的命令，而后面的单词都是这个命令的参数。
2. 管道，管道是有控制字符，\|或者\|& 分隔开的一系列的简单指令。

> time -p command1 [\|或者\|&] command2

管道里的每个命令的输出都经由管道与下一个命令的输入相连接，也就是说每个命令都去读取上一个命令的输出。这种连接早在命令中指定的任何重定向之前就已经进行了。

如果使用了\|&这种管道，command1的标准错误输出将会和command2的标准输出相连接，这是command2>&command1 \|的简写形式，这种对标准错误输出的隐藏重定向是在命令中指定任何的重定向之后进行的。

这里面的time指令会在管道执行完毕后输出其执行的时间的统计信息。
3. 命令的队列，命令的队列是由一个或者管道通过运算符; & && \|\| 连接而成，最后还可以由; &或者换行符结束。
- 在这些队列运算中，&& 和\|\|具有相同的优先级，其次是&和；，这两个也具有同样的优先级。
- 在命令队列中可以使用一个或者多个换行符分隔命令，这与分号是等价的。
- 如果一个命令是由控制字符&结束，则shell会不同步在子shell中执行该命令，我们通常称之为后台。这时shell并不等待命令的结束，而是返回状态0（即逻辑真）。如果我们没有启动作业控制，并且也没有显示指定重定向，那么则在一步执行的命令的标准输入将被重定向到/dev/mull。也就是啥也没有了。
- 由；分隔的命令，将会相继执行。shell依次等待每个命令的结束，整个返回状态是最后一个要执行的命令的返回状态。
- “与”或者“和”命令队列是分别由\|\|和&&分隔的一个或者多个管道。

- 命令1 && 命令2
- 仅当第一个命令返回值为0的时候，才执行第二个命令

- 命令2 \|\| 命令2
- 仅当第一个命令返回非0值的时候，才执行第二个命令
- “与”或者“和”命令队列返回的值是最后一个被执行的命令的值。

4. 复合命令

复合命令是shell 编程的结构体，每个结构体都是以保留字或者控制运算符开头，然后以与之对应的保留字或者控制运算符号结束，任何复合命令相关的重定向，都做用于改复合命令里面的所有命令除非显示覆盖。
bash提供：
- 循环结构

> until  循环结构
> 
> until 测试命令；do 命令块；done
> 
> 只要测试命令返回非零，就执行模块，返回值是命令块中执行后的对应的返回值，如果命令块没有被执行，那么返回零。
> 命令块是指一条或者几条命令的罗列或者组合。
> 0表示真值，也就是说测试命令通过。

> while 循环结构
> 
> while 测试命令；do 命令块；done
> 
> 只要测试命令返回零，就执行模块，返回值是命令块中执行后的对应的返回值，如果命令块没有被执行，那么返回零。

> for 循环
> 
> for 变量 in [单词]；do 命令块；done
> 
> 将单词扩展成一个列表，然后吧结果中列表的每个元素都赋值给变量，并执行一次命令模块，如果没有in[单词]这个部分，则for一次对每个位置参数都执行一个命令块，好像指定了 in $@ 一样，返回值是命令块中，最后一次执行后的结果，如果对单词的扩展没有得到任何元素，则不执行命令，并返回零。
> 
> for 命令还支持另一种格式：
> 
> for ((表达式1；表达式2；表达式3))；do 命令块 ；done
> 
> 这个意思就是，按照shell的运算规则，对表达式1进行运算求值，然后不断对表达式2进行求值，直到结果为零，如果不为零，就执行一次命令块，并计算表达式三。如果省略了任何一个表达式，则效果就像该表达式总是返回1，其返回值是命令块中最后一个被执行的命令的返回值。如果表达式的值都是假的，则返回假，即非零。

> 分节结束
> 
> 可以使用内置的命令break和continue来控制循环命令的执行。

- 条件结构

> if 条件结构
> 
> if 测试命令；then
> 
> 命令块1
> 
> elif 测试命令；then
> 
> 命令块2
> 
> else
> 
> 其他命令块
> 
> fi
> 
> 这个不用多解释。

> case 条件结构
> 
> case 单词 in
> 
> （第一种模式\|第二种模式\|第三种模式）
> 
> 命令块；；
> 
> 第四种模式\|第五种模式）
>  > 命令块；；
> 
> *）
> 
> 命令块；；
> 
> esac
> 
> case命令会选择性执行与单词所匹配的第一个模式对应的命令块。
> 
> case的分分句的数量不限，但是每个分句都以;; ,& ;;& 这三种结束，最先匹配的模式决定了那个模块被执行。
> 
> 模式列表前面可以加一个对‘）’对应的‘（’，但是不是必须的。所以说，case里面，括号都是一半的。

> select 条件结构
> 
> select 名称 in [单词表]；do 命令块；done
> 
> 这个命令的格式几乎和for命令一摸一样。
> 
> in后面的单词表被扩展并生成一个项目列表。注意，这个扩展后的列表将会打印到标准错误输出流中，并且每个项目前面都会加上一个序数。如果省略了in [单词表]部分，则打印位置参数，就好像使用了 in $@  一样。
> 
> select结构使得菜单的生成变的简单。

> (( )) 条件结构
> 
> ((算数表达式))
> 
> 根据shell 的算数运算的规则，对算数表达式求值，如果这个值不是零，则返回状态是0，否则返回1.
> 
> 这个指令与 let “表达式” 完全等价。

> [[条件表达式]]
> 
> 对于条件表达式求值，并根据其结果返回0或者1，条件表达式是由原子成分组成的，在中间的单词不会进行单词和文件名扩展，但却进行波浪号扩展，参数和变量扩展算数扩展命令替换，进程替换以及引用去除。诸如 -f 等条件运算符不能被引用，否则她们就不是原子表达式了。
> 
> 如果使用==和!=运算符，则运算符的右边会看成是一个模式，如果使用了==，并且字符串匹配，或者使用了！=，字符串不匹配，则返回值是0，否则返回1。模式的任何部分都可以背引用以强制把其当作字符串来匹配。
> 
> 还有一个=～，双目运算符，他和==和！=具有同样的优先级，如果字符串和模式匹配，则其右边的字符串就被认为是一个扩展的正则表达式来匹配。

- 命令分组并整体执行

> ()
> 
> (表达式)
> 
> 把一列命令放在括号中间，就会创建一个子shell环境，并在这个字shell中执行该列表中的每个值，因为这个命令列表实在子shell中执行的，所以在子shell结束后，其中的变量复制将不再有效。

> {}
> 
> {表达式；}
> 
> 把一列命令放在大括号里，这列命令九回在当前的shell中执行，而不是创建子shell，列表后面的顿号是必须的。

> 在bash的分隔符中，；是使用的最频繁的，他出了具有分隔的作用，没有其他任何含义，所以，在任何命令的末尾，都可以使用它，但如果一个命令单独成行，这个符号完全可以省略。

- 出了子shell的创建，上述两种结构之间由于历史原因还有微妙的差别，大括号是保留字，所以它与命令列表之间必须用空白符或其他的元字符分开，而圆括号是运算符，所以它既是它们和命令列表直接没有空白符分开，也会被其中的命令当作独立的符号。

5. 协同进程，协同进程coprocess 是指一个shell命令前面面有coproc保留字；它是在子shell中异步执行的，就好像这个命令后面有控制运算符&一样，协同进程和气父进程之间有双向管道，这个命令的格式是：

> coproc [NAME] 命令 [重定向]
> 
> 上述命令创建了一个名为NAME的协同进程，如果没有指定name，那么默认的名称是COPROC，如果这里的命令指示一个简单的命令，则不能指定NAME，否则它会被当成命令的第一个单词。
> 
> coproc被执行的时候，shell会在父进程中创建一个名为那么的变量组，命令的标准输出通过管道和父进程的一个文件描述符相连接，该文件的描述符被付给name[0]，类似的，命令的标准输入通过管 道和父进程的一个文件描述符相连;该文件描述符被赋给 NAME[1]。这个管道是在命令当中指定的任何重定向之前就建立了。这些文件描述符可以在shell命令和重定向中通过标准的单词扩展而当作参数使用。

#### shell的函数
#### shell的参数
#### shell的扩展
#### 重定向
#### 命令的执行
#### shell的脚本

### 第四章 shell的内部命令

#### bsh(bash的前身)的内部命令
#### bash的内部命令
#### 改变shell的行为
#### 特殊的内部命令

### 第五章 shell的变量

#### bsh(bash的前身)的变量
#### bash的变量

### 第六章 bash的功能

#### bash的启动
#### bash的启动脚本
#### 交互式的shell
#### bash的条件表达式
#### shell的算数运算
#### 别名
#### 数组
#### 目录栈
#### 提示符的控制
#### 受限制的bash
#### bash的posix模式

### 第七章 作业控制

#### 作业控制的基础
#### 作业控制的内部命令
#### 作业控制的变量

### 第八章 编辑命令行

#### 行编辑介绍
#### 与readline的交互
#### readline的启动脚本
#### 可以绑定的readline命令
#### 可编程的补全
#### 可编程的补全内部命令

### 第九章 历史的交互使用

#### bash的历史功能
#### bash的历史内部命令
#### 历史扩展

### 第十章 bash的安装

#### 基本安装
#### 安装路径
#### 选择系统类型
#### 抹人设置的共享
#### 控制配置的脚本
#### 配置选项




### 附录 贴图

在最后贴几张图，这些图用来以后用到的时候能够快速查找。

![](http://i1.piimg.com/593397/c2024966e78b43f8.png)

![](http://i1.piimg.com/593397/93253d896bfe56ab.jpg)

![](http://i1.piimg.com/593397/c100d4a613392561.jpg)

![](http://i1.piimg.com/593397/e279be21c7c06531.jpg)

![](http://i1.piimg.com/593397/5a465ea6616a334b.jpg)

![](http://i1.piimg.com/593397/6848a9fc268c3469.jpg)


